{"version":3,"sources":["../../src/utilities/transform.ts"],"sourcesContent":["import type {\n  CollectionConfig,\n  DateField,\n  Field,\n  FlattenedBlock,\n  FlattenedField,\n  JoinField,\n  RelationshipField,\n  SanitizedConfig,\n  TraverseFieldsCallback,\n  UploadField,\n} from 'payload'\n\nimport { Types } from 'mongoose'\nimport { flattenAllFields, traverseFields } from 'payload'\nimport { fieldAffectsData, fieldShouldBeLocalized } from 'payload/shared'\n\nimport type { MongooseAdapter } from '../index.js'\n\nimport { isObjectID } from './isObjectID.js'\n\ninterface RelationObject {\n  relationTo: string\n  value: number | string\n}\n\nfunction isValidRelationObject(value: unknown): value is RelationObject {\n  return typeof value === 'object' && value !== null && 'relationTo' in value && 'value' in value\n}\n\n/**\n * Process relationship values for polymorphic and simple relationships\n * Used by both $push and $remove operations\n */\nconst processRelationshipValues = (\n  items: unknown[],\n  field: RelationshipField | UploadField,\n  config: SanitizedConfig,\n  operation: 'read' | 'write',\n  validateRelationships: boolean,\n  adapter: MongooseAdapter,\n) => {\n  return items.map((item) => {\n    // Handle polymorphic relationships\n    if (Array.isArray(field.relationTo) && isValidRelationObject(item)) {\n      const relatedCollection = config.collections?.find(({ slug }) => slug === item.relationTo)\n      if (relatedCollection) {\n        return {\n          relationTo: item.relationTo,\n          value: convertRelationshipValue({\n            adapter,\n            operation,\n            relatedCollection,\n            validateRelationships,\n            value: item.value,\n          }),\n        }\n      }\n      return item\n    }\n\n    // Handle simple relationships\n    if (typeof field.relationTo === 'string') {\n      const relatedCollection = config.collections?.find(({ slug }) => slug === field.relationTo)\n      if (relatedCollection) {\n        return convertRelationshipValue({\n          adapter,\n          operation,\n          relatedCollection,\n          validateRelationships,\n          value: item,\n        })\n      }\n    }\n\n    return item\n  })\n}\n\nconst convertRelationshipValue = ({\n  adapter,\n  operation,\n  relatedCollection,\n  validateRelationships,\n  value,\n}: {\n  adapter: MongooseAdapter\n  operation: Args['operation']\n  relatedCollection: CollectionConfig\n  validateRelationships?: boolean\n  value: unknown\n}) => {\n  const customIDField = relatedCollection.fields.find(\n    (field) => fieldAffectsData(field) && field.name === 'id',\n  )\n\n  if (operation === 'read') {\n    if (isObjectID(value)) {\n      return value.toHexString()\n    }\n\n    if (\n      customIDField?.type === 'number' &&\n      typeof value === 'bigint' &&\n      adapter.useBigIntForNumberIDs\n    ) {\n      return Number(value)\n    }\n\n    return value\n  }\n\n  if (customIDField) {\n    return value\n  }\n\n  if (typeof value === 'string') {\n    try {\n      return new Types.ObjectId(value)\n    } catch (e) {\n      if (validateRelationships) {\n        throw e\n      }\n      return value\n    }\n  }\n\n  return value\n}\n\nconst sanitizeRelationship = ({\n  adapter,\n  config,\n  field,\n  locale,\n  operation,\n  ref,\n  validateRelationships,\n  value,\n}: {\n  adapter: MongooseAdapter\n  config: SanitizedConfig\n  field: JoinField | RelationshipField | UploadField\n  locale?: string\n  operation: Args['operation']\n  ref: Record<string, unknown>\n  validateRelationships?: boolean\n  value?: unknown\n}) => {\n  if (field.type === 'join') {\n    if (\n      operation === 'read' &&\n      value &&\n      typeof value === 'object' &&\n      'docs' in value &&\n      Array.isArray(value.docs)\n    ) {\n      for (let i = 0; i < value.docs.length; i++) {\n        const item = value.docs[i]\n\n        if (isObjectID(item)) {\n          value.docs[i] = item.toHexString()\n        } else if (Array.isArray(field.collection) && item) {\n          // Fields here for polymorphic joins cannot be determinted, JSON.parse needed\n          value.docs[i] = JSON.parse(JSON.stringify(value.docs[i]))\n        }\n      }\n    }\n\n    return value\n  }\n  let relatedCollection: CollectionConfig | undefined\n  let result = value\n\n  const hasManyRelations = typeof field.relationTo !== 'string'\n\n  if (!hasManyRelations) {\n    relatedCollection = config.collections?.find(({ slug }) => slug === field.relationTo)\n  }\n\n  if (Array.isArray(value)) {\n    result = value.map((val) => {\n      // Handle has many - polymorphic\n      if (isValidRelationObject(val)) {\n        const relatedCollectionForSingleValue = config.collections?.find(\n          ({ slug }) => slug === val.relationTo,\n        )\n\n        if (relatedCollectionForSingleValue) {\n          return {\n            relationTo: val.relationTo,\n            value: convertRelationshipValue({\n              adapter,\n              operation,\n              relatedCollection: relatedCollectionForSingleValue,\n              validateRelationships,\n              value: val.value,\n            }),\n          }\n        }\n      }\n\n      if (relatedCollection) {\n        return convertRelationshipValue({\n          adapter,\n          operation,\n          relatedCollection,\n          validateRelationships,\n          value: val,\n        })\n      }\n\n      return val\n    })\n  }\n  // Handle has one - polymorphic\n  else if (isValidRelationObject(value)) {\n    relatedCollection = config.collections?.find(({ slug }) => slug === value.relationTo)\n\n    if (relatedCollection) {\n      result = {\n        relationTo: value.relationTo,\n        value: convertRelationshipValue({\n          adapter,\n          operation,\n          relatedCollection,\n          validateRelationships,\n          value: value.value,\n        }),\n      }\n    }\n  }\n  // Handle has one\n  else if (relatedCollection) {\n    result = convertRelationshipValue({\n      adapter,\n      operation,\n      relatedCollection,\n      validateRelationships,\n      value,\n    })\n  }\n\n  if (locale) {\n    ref[locale] = result\n  } else {\n    ref[field.name] = result\n  }\n}\n\nconst sanitizeDate = ({\n  field,\n  locale,\n  ref,\n  value,\n}: {\n  field: DateField\n  locale?: string\n  ref: Record<string, unknown>\n  value: unknown\n}) => {\n  if (!value) {\n    return\n  }\n\n  if (value instanceof Date) {\n    value = value.toISOString()\n  }\n\n  if (locale) {\n    ref[locale] = value\n  } else {\n    ref[field.name] = value\n  }\n}\n\ntype Args = {\n  $addToSet?: Record<string, { $each: any[] } | any>\n  $inc?: Record<string, number>\n  $pull?: Record<string, { $in: any[] } | any>\n  $push?: Record<string, { $each: any[] } | any>\n  /** instance of the adapter */\n  adapter: MongooseAdapter\n  /** data to transform, can be an array of documents or a single document */\n  data: Record<string, unknown> | Record<string, unknown>[]\n  /** fields accossiated with the data */\n  fields: Field[]\n  /** slug of the global, pass only when the operation is `write` */\n  globalSlug?: string\n  /**\n   * Type of the operation\n   * read - sanitizes ObjectIDs, Date to strings.\n   * write - sanitizes string relationships to ObjectIDs.\n   */\n  operation: 'read' | 'write'\n  parentIsLocalized?: boolean\n  /**\n   * Throw errors on invalid relationships\n   * @default true\n   */\n  validateRelationships?: boolean\n}\n\nconst stripFields = ({\n  config,\n  data,\n  fields,\n  reservedKeys = [],\n}: {\n  config: SanitizedConfig\n  data: any\n  fields: FlattenedField[]\n  reservedKeys?: string[]\n}) => {\n  for (const k in data) {\n    if (!fields.some((field) => field.name === k) && !reservedKeys.includes(k)) {\n      delete data[k]\n    }\n  }\n\n  for (const field of fields) {\n    reservedKeys = []\n    const fieldData = data[field.name]\n    if (!fieldData || typeof fieldData !== 'object') {\n      continue\n    }\n\n    if (field.type === 'blocks') {\n      reservedKeys.push('blockType')\n    }\n\n    if ('flattenedFields' in field || 'blocks' in field) {\n      if (field.localized && config.localization) {\n        for (const localeKey in fieldData) {\n          if (!config.localization.localeCodes.some((code) => code === localeKey)) {\n            delete fieldData[localeKey]\n            continue\n          }\n\n          const localeData = fieldData[localeKey]\n\n          if (!localeData || typeof localeData !== 'object') {\n            if (field.type === 'blocks') {\n              fieldData[localeKey] = []\n            }\n            continue\n          }\n\n          if (field.type === 'array' || field.type === 'blocks') {\n            if (!Array.isArray(localeData)) {\n              continue\n            }\n\n            let hasNull = false\n            for (let i = 0; i < localeData.length; i++) {\n              const data = localeData[i]\n              let fields: FlattenedField[] | null = null\n\n              if (field.type === 'array') {\n                fields = field.flattenedFields\n              } else {\n                let maybeBlock: FlattenedBlock | undefined = undefined\n\n                if (field.blockReferences) {\n                  const maybeBlockReference = field.blockReferences.find((each) => {\n                    const slug = typeof each === 'string' ? each : each.slug\n                    return slug === data.blockType\n                  })\n\n                  if (maybeBlockReference) {\n                    if (typeof maybeBlockReference === 'object') {\n                      maybeBlock = maybeBlockReference\n                    } else {\n                      maybeBlock = config.blocks?.find((each) => each.slug === maybeBlockReference)\n                    }\n                  }\n                }\n\n                if (!maybeBlock) {\n                  maybeBlock = field.blocks.find((each) => each.slug === data.blockType)\n                }\n\n                if (maybeBlock) {\n                  fields = maybeBlock.flattenedFields\n                } else {\n                  localeData[i] = null\n                  hasNull = true\n                }\n              }\n\n              if (!fields) {\n                continue\n              }\n\n              stripFields({ config, data, fields, reservedKeys })\n            }\n\n            if (hasNull) {\n              fieldData[localeKey] = localeData.filter(Boolean)\n            }\n\n            continue\n          } else {\n            stripFields({ config, data: localeData, fields: field.flattenedFields, reservedKeys })\n          }\n        }\n        continue\n      }\n\n      if (field.type === 'array' || field.type === 'blocks') {\n        if (!Array.isArray(fieldData)) {\n          continue\n        }\n\n        let hasNull = false\n\n        for (let i = 0; i < fieldData.length; i++) {\n          const data = fieldData[i]\n          let fields: FlattenedField[] | null = null\n\n          if (field.type === 'array') {\n            fields = field.flattenedFields\n          } else {\n            let maybeBlock: FlattenedBlock | undefined = undefined\n\n            if (field.blockReferences) {\n              const maybeBlockReference = field.blockReferences.find((each) => {\n                const slug = typeof each === 'string' ? each : each.slug\n                return slug === data.blockType\n              })\n\n              if (maybeBlockReference) {\n                if (typeof maybeBlockReference === 'object') {\n                  maybeBlock = maybeBlockReference\n                } else {\n                  maybeBlock = config.blocks?.find((each) => each.slug === maybeBlockReference)\n                }\n              }\n            }\n\n            if (!maybeBlock) {\n              maybeBlock = field.blocks.find((each) => each.slug === data.blockType)\n            }\n\n            if (maybeBlock) {\n              fields = maybeBlock.flattenedFields\n            } else {\n              fieldData[i] = null\n              hasNull = true\n            }\n          }\n\n          if (!fields) {\n            continue\n          }\n\n          stripFields({ config, data, fields, reservedKeys })\n        }\n\n        if (hasNull) {\n          data[field.name] = fieldData.filter(Boolean)\n        }\n\n        continue\n      } else {\n        stripFields({ config, data: fieldData, fields: field.flattenedFields, reservedKeys })\n      }\n    }\n  }\n}\n\nexport const transform = ({\n  $addToSet,\n  $inc,\n  $pull,\n  $push,\n  adapter,\n  data,\n  fields,\n  globalSlug,\n  operation,\n  parentIsLocalized = false,\n  validateRelationships = true,\n}: Args) => {\n  if (!data) {\n    return null\n  }\n\n  if (Array.isArray(data)) {\n    for (const item of data) {\n      transform({\n        $addToSet,\n        $inc,\n        $pull,\n        $push,\n        adapter,\n        data: item,\n        fields,\n        globalSlug,\n        operation,\n        validateRelationships,\n      })\n    }\n    return\n  }\n\n  const {\n    payload: { config },\n  } = adapter\n\n  if (operation === 'read') {\n    delete data['__v']\n    data.id = data._id || data.id\n    delete data['_id']\n\n    if (isObjectID(data.id)) {\n      data.id = data.id.toHexString()\n    }\n\n    // Handle BigInt conversion for custom ID fields of type 'number'\n    if (adapter.useBigIntForNumberIDs && typeof data.id === 'bigint') {\n      data.id = Number(data.id)\n    }\n\n    if (!adapter.allowAdditionalKeys) {\n      stripFields({\n        config,\n        data,\n        fields: flattenAllFields({ cache: true, fields }),\n        reservedKeys: ['id', 'globalType'],\n      })\n    }\n  }\n\n  if (operation === 'write' && globalSlug) {\n    data.globalType = globalSlug\n  }\n\n  const sanitize: TraverseFieldsCallback = ({\n    field,\n    parentIsLocalized,\n    parentPath,\n    parentRef: incomingParentRef,\n    ref: incomingRef,\n  }) => {\n    if (!incomingRef || typeof incomingRef !== 'object') {\n      return\n    }\n\n    const ref = incomingRef as Record<string, unknown>\n    const parentRef = (incomingParentRef || {}) as Record<string, unknown>\n\n    // Clear empty parent containers by setting them to undefined.\n    const clearEmptyContainer = () => {\n      if (!parentRef || typeof parentRef !== 'object') {\n        return\n      }\n      if (!ref || typeof ref !== 'object') {\n        return\n      }\n      if (Object.keys(ref).length > 0) {\n        return\n      }\n      const containerKey = Object.keys(parentRef).find((k) => parentRef[k] === ref)\n      if (containerKey) {\n        parentRef[containerKey] = undefined\n      }\n    }\n\n    if (\n      $inc &&\n      field.type === 'number' &&\n      operation === 'write' &&\n      field.name in ref &&\n      ref[field.name]\n    ) {\n      const value = ref[field.name]\n      if (value && typeof value === 'object' && '$inc' in value && typeof value.$inc === 'number') {\n        $inc[`${parentPath}${field.name}`] = value.$inc\n        delete ref[field.name]\n        clearEmptyContainer()\n      }\n    }\n\n    if (\n      $push &&\n      field.type === 'array' &&\n      operation === 'write' &&\n      field.name in ref &&\n      ref[field.name]\n    ) {\n      const value = ref[field.name]\n\n      if (\n        value &&\n        typeof value === 'object' &&\n        ('$push' in value ||\n          (config.localization &&\n            fieldShouldBeLocalized({ field, parentIsLocalized }) &&\n            Object.values(value).some(\n              (localeValue) =>\n                localeValue && typeof localeValue === 'object' && '$push' in localeValue,\n            )))\n      ) {\n        if (config.localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n          // Handle localized fields: { field: { locale: { $push: data } } }\n          let hasLocaleOperations = false\n          Object.entries(value).forEach(([localeKey, localeValue]) => {\n            if (localeValue && typeof localeValue === 'object' && '$push' in localeValue) {\n              hasLocaleOperations = true\n              const push = localeValue.$push\n              if (Array.isArray(push)) {\n                $push[`${parentPath}${field.name}.${localeKey}`] = { $each: push }\n              } else if (typeof push === 'object') {\n                $push[`${parentPath}${field.name}.${localeKey}`] = push\n              }\n            }\n          })\n\n          if (hasLocaleOperations) {\n            delete ref[field.name]\n            clearEmptyContainer()\n          }\n        } else if (value && typeof value === 'object' && '$push' in value) {\n          // Handle non-localized fields: { field: { $push: data } }\n          const push = value.$push\n          if (Array.isArray(push)) {\n            $push[`${parentPath}${field.name}`] = { $each: push }\n          } else if (typeof push === 'object') {\n            $push[`${parentPath}${field.name}`] = push\n          }\n          delete ref[field.name]\n          clearEmptyContainer()\n        }\n      }\n    }\n\n    // Handle $push operation for relationship fields (converts to $addToSet)\n\n    // Handle $push operation for relationship fields (converts to $addToSet) - unified approach\n    if (\n      $addToSet &&\n      (field.type === 'relationship' || field.type === 'upload') &&\n      'hasMany' in field &&\n      field.hasMany &&\n      operation === 'write' &&\n      field.name in ref &&\n      ref[field.name]\n    ) {\n      const value = ref[field.name]\n\n      if (\n        value &&\n        typeof value === 'object' &&\n        ('$push' in value ||\n          (config.localization &&\n            fieldShouldBeLocalized({ field, parentIsLocalized }) &&\n            Object.values(value).some(\n              (localeValue) =>\n                localeValue &&\n                typeof localeValue === 'object' &&\n                '$push' in (localeValue as Record<string, unknown>),\n            )))\n      ) {\n        if (config.localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n          // Handle localized fields: { field: { locale: { $push: data } } }\n          let hasLocaleOperations = false\n          Object.entries(value).forEach(([localeKey, localeValue]) => {\n            if (localeValue && typeof localeValue === 'object' && '$push' in localeValue) {\n              hasLocaleOperations = true\n              const push = localeValue.$push\n              const localeItems = Array.isArray(push) ? push : [push]\n              const processedLocaleItems = processRelationshipValues(\n                localeItems,\n                field,\n                config,\n                operation,\n                validateRelationships,\n                adapter,\n              )\n              $addToSet[`${parentPath}${field.name}.${localeKey}`] = { $each: processedLocaleItems }\n            }\n          })\n\n          if (hasLocaleOperations) {\n            delete ref[field.name]\n            clearEmptyContainer()\n          }\n        } else if (value && typeof value === 'object' && '$push' in value) {\n          // Handle non-localized fields: { field: { $push: data } }\n          const itemsToAppend = Array.isArray(value.$push) ? value.$push : [value.$push]\n          const processedItems = processRelationshipValues(\n            itemsToAppend,\n            field,\n            config,\n            operation,\n            validateRelationships,\n            adapter,\n          )\n          $addToSet[`${parentPath}${field.name}`] = { $each: processedItems }\n          delete ref[field.name]\n          clearEmptyContainer()\n        }\n      }\n    }\n\n    // Handle $remove operation for relationship fields (converts to $pull)\n    if (\n      $pull &&\n      (field.type === 'relationship' || field.type === 'upload') &&\n      'hasMany' in field &&\n      field.hasMany &&\n      operation === 'write' &&\n      field.name in ref &&\n      ref[field.name]\n    ) {\n      const value = ref[field.name]\n      if (\n        value &&\n        typeof value === 'object' &&\n        ('$remove' in value ||\n          (config.localization &&\n            fieldShouldBeLocalized({ field, parentIsLocalized }) &&\n            Object.values(value).some(\n              (localeValue) =>\n                localeValue &&\n                typeof localeValue === 'object' &&\n                '$remove' in (localeValue as Record<string, unknown>),\n            )))\n      ) {\n        if (config.localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n          // Handle localized fields: { field: { locale: { $remove: data } } }\n          let hasLocaleOperations = false\n          Object.entries(value).forEach(([localeKey, localeValue]) => {\n            if (localeValue && typeof localeValue === 'object' && '$remove' in localeValue) {\n              hasLocaleOperations = true\n              const remove = localeValue.$remove\n              const localeItems = Array.isArray(remove) ? remove : [remove]\n              const processedLocaleItems = processRelationshipValues(\n                localeItems,\n                field,\n                config,\n                operation,\n                validateRelationships,\n                adapter,\n              )\n              $pull[`${parentPath}${field.name}.${localeKey}`] = { $in: processedLocaleItems }\n            }\n          })\n\n          if (hasLocaleOperations) {\n            delete ref[field.name]\n            clearEmptyContainer()\n          }\n        } else if (value && typeof value === 'object' && '$remove' in value) {\n          // Handle non-localized fields: { field: { $remove: data } }\n          const itemsToRemove = Array.isArray(value.$remove) ? value.$remove : [value.$remove]\n          const processedItems = processRelationshipValues(\n            itemsToRemove,\n            field,\n            config,\n            operation,\n            validateRelationships,\n            adapter,\n          )\n          $pull[`${parentPath}${field.name}`] = { $in: processedItems }\n          delete ref[field.name]\n          clearEmptyContainer()\n        }\n      }\n    }\n\n    if (field.type === 'date' && operation === 'read' && field.name in ref && ref[field.name]) {\n      if (config.localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n        const fieldRef = ref[field.name] as Record<string, unknown>\n        if (!fieldRef || typeof fieldRef !== 'object') {\n          return\n        }\n\n        for (const locale of config.localization.localeCodes) {\n          sanitizeDate({\n            field,\n            locale,\n            ref: fieldRef,\n            value: fieldRef[locale],\n          })\n        }\n      } else {\n        sanitizeDate({\n          field,\n          ref,\n          value: ref[field.name],\n        })\n      }\n    }\n\n    if (\n      field.type === 'relationship' ||\n      field.type === 'upload' ||\n      (operation === 'read' && field.type === 'join')\n    ) {\n      if (!ref[field.name]) {\n        return\n      }\n\n      // handle localized relationships\n      if (config.localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n        const locales = config.localization.locales\n        const fieldRef = ref[field.name] as Record<string, unknown>\n        if (typeof fieldRef !== 'object') {\n          return\n        }\n\n        for (const { code } of locales) {\n          const value = fieldRef[code]\n          if (value) {\n            sanitizeRelationship({\n              adapter,\n              config,\n              field,\n              locale: code,\n              operation,\n              ref: fieldRef,\n              validateRelationships,\n              value,\n            })\n          }\n        }\n      } else {\n        // handle non-localized relationships\n        sanitizeRelationship({\n          adapter,\n          config,\n          field,\n          locale: undefined,\n          operation,\n          ref,\n          validateRelationships,\n          value: ref[field.name],\n        })\n      }\n    }\n  }\n\n  traverseFields({\n    callback: sanitize,\n    config,\n    fields,\n    fillEmpty: false,\n    parentIsLocalized,\n    ref: data,\n  })\n\n  if (operation === 'write') {\n    if (typeof data.updatedAt === 'undefined') {\n      // If data.updatedAt is explicitly set to `null` we should not set it - this means we don't want to change the value of updatedAt.\n      data.updatedAt = new Date().toISOString()\n    } else if (data.updatedAt === null) {\n      // `updatedAt` may be explicitly set to null to disable updating it - if that is the case, we need to delete the property. Keeping it as null will\n      // cause the database to think we want to set it to null, which we don't.\n      delete data.updatedAt\n    }\n  }\n}\n"],"names":["Types","flattenAllFields","traverseFields","fieldAffectsData","fieldShouldBeLocalized","isObjectID","isValidRelationObject","value","processRelationshipValues","items","field","config","operation","validateRelationships","adapter","map","item","Array","isArray","relationTo","relatedCollection","collections","find","slug","convertRelationshipValue","customIDField","fields","name","toHexString","type","useBigIntForNumberIDs","Number","ObjectId","e","sanitizeRelationship","locale","ref","docs","i","length","collection","JSON","parse","stringify","result","hasManyRelations","val","relatedCollectionForSingleValue","sanitizeDate","Date","toISOString","stripFields","data","reservedKeys","k","some","includes","fieldData","push","localized","localization","localeKey","localeCodes","code","localeData","hasNull","flattenedFields","maybeBlock","undefined","blockReferences","maybeBlockReference","each","blockType","blocks","filter","Boolean","transform","$addToSet","$inc","$pull","$push","globalSlug","parentIsLocalized","payload","id","_id","allowAdditionalKeys","cache","globalType","sanitize","parentPath","parentRef","incomingParentRef","incomingRef","clearEmptyContainer","Object","keys","containerKey","values","localeValue","hasLocaleOperations","entries","forEach","$each","hasMany","localeItems","processedLocaleItems","itemsToAppend","processedItems","remove","$remove","$in","itemsToRemove","fieldRef","locales","callback","fillEmpty","updatedAt"],"mappings":"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"}