{"version":3,"sources":["../../src/utilities/buildJoinAggregation.ts"],"sourcesContent":["import type { PipelineStage } from 'mongoose'\n\nimport {\n  APIError,\n  appendVersionToQueryKey,\n  buildVersionCollectionFields,\n  type CollectionSlug,\n  combineQueries,\n  type FlattenedField,\n  getQueryDraftsSort,\n  type JoinQuery,\n  type SanitizedCollectionConfig,\n} from 'payload'\nimport { fieldShouldBeLocalized } from 'payload/shared'\n\nimport type { MongooseAdapter } from '../index.js'\nimport type { CollectionModel } from '../types.js'\n\nimport { buildQuery } from '../queries/buildQuery.js'\nimport { buildSortParam } from '../queries/buildSortParam.js'\nimport { getCollection } from './getEntity.js'\n\ntype BuildJoinAggregationArgs = {\n  adapter: MongooseAdapter\n  collection: CollectionSlug\n  collectionConfig: SanitizedCollectionConfig\n  draftsEnabled?: boolean\n  joins?: JoinQuery\n  locale?: string\n  projection?: Record<string, true>\n  // the where clause for the top collection\n  query?: Record<string, unknown>\n  /** whether the query is from drafts */\n  versions?: boolean\n}\n\nexport const buildJoinAggregation = async ({\n  adapter,\n  collection,\n  collectionConfig,\n  draftsEnabled,\n  joins,\n  locale,\n  projection,\n  versions,\n}: BuildJoinAggregationArgs): Promise<PipelineStage[] | undefined> => {\n  if (!adapter.useJoinAggregations) {\n    return\n  }\n  if (\n    (Object.keys(collectionConfig.joins).length === 0 &&\n      collectionConfig.polymorphicJoins.length == 0) ||\n    joins === false\n  ) {\n    return\n  }\n\n  const joinConfig = adapter.payload.collections[collection]?.config?.joins\n\n  if (!joinConfig) {\n    throw new APIError(`Could not retrieve sanitized join config for ${collection}.`)\n  }\n\n  const aggregate: PipelineStage[] = []\n  const polymorphicJoinsConfig = adapter.payload.collections[collection]?.config?.polymorphicJoins\n\n  if (!polymorphicJoinsConfig) {\n    throw new APIError(`Could not retrieve sanitized polymorphic joins config for ${collection}.`)\n  }\n\n  for (const join of polymorphicJoinsConfig) {\n    if (projection && !projection[join.joinPath]) {\n      continue\n    }\n\n    if (joins?.[join.joinPath] === false) {\n      continue\n    }\n\n    const {\n      count = false,\n      limit: limitJoin = join.field.defaultLimit ?? 10,\n      page,\n      sort: sortJoin = join.field.defaultSort || collectionConfig.defaultSort,\n      where: whereJoin = {},\n    } = joins?.[join.joinPath] || {}\n\n    const aggregatedFields: FlattenedField[] = []\n    for (const collectionSlug of join.field.collection) {\n      const { collectionConfig } = getCollection({ adapter, collectionSlug })\n\n      for (const field of collectionConfig.flattenedFields) {\n        if (!aggregatedFields.some((eachField) => eachField.name === field.name)) {\n          aggregatedFields.push(field)\n        }\n      }\n    }\n\n    const sort = buildSortParam({\n      adapter,\n      config: adapter.payload.config,\n      fields: aggregatedFields,\n      locale,\n      sort: sortJoin,\n      timestamps: true,\n    })\n\n    const $match = await buildQuery({\n      adapter,\n      fields: aggregatedFields,\n      locale,\n      where: whereJoin,\n    })\n\n    const sortProperty = Object.keys(sort)[0]! // assert because buildSortParam always returns at least 1 key.\n    const sortDirection = sort[sortProperty] === 'asc' ? 1 : -1\n\n    const projectSort = sortProperty !== '_id' && sortProperty !== 'relationTo'\n\n    const aliases: string[] = []\n\n    const as = join.joinPath\n\n    for (const collectionSlug of join.field.collection) {\n      const alias = `${as}.docs.${collectionSlug}`\n      aliases.push(alias)\n\n      const basePipeline = [\n        {\n          $addFields: {\n            relationTo: {\n              $literal: collectionSlug,\n            },\n          },\n        },\n        {\n          $match: {\n            $and: [\n              {\n                $expr: {\n                  $eq: [`$${join.field.on}`, '$$root_id_'],\n                },\n              },\n              $match,\n            ],\n          },\n        },\n      ]\n\n      const { Model: JoinModel } = getCollection({ adapter, collectionSlug })\n\n      aggregate.push({\n        $lookup: {\n          as: alias,\n          from: JoinModel.collection.name,\n          let: {\n            root_id_: '$_id',\n          },\n          pipeline: [\n            ...basePipeline,\n            {\n              $sort: {\n                [sortProperty]: sortDirection,\n              },\n            },\n            {\n              // Unfortunately, we can't use $skip here because we can lose data, instead we do $slice then\n              $limit: page ? page * limitJoin : limitJoin,\n            },\n            {\n              $project: {\n                value: '$_id',\n                ...(projectSort && {\n                  [sortProperty]: 1,\n                }),\n                relationTo: 1,\n              },\n            },\n          ],\n        },\n      })\n\n      if (count) {\n        aggregate.push({\n          $lookup: {\n            as: `${as}.totalDocs.${alias}`,\n            from: JoinModel.collection.name,\n            let: {\n              root_id_: '$_id',\n            },\n            pipeline: [\n              ...basePipeline,\n              {\n                $count: 'result',\n              },\n            ],\n          },\n        })\n      }\n    }\n\n    aggregate.push({\n      $addFields: {\n        [`${as}.docs`]: {\n          $concatArrays: aliases.map((alias) => `$${alias}`),\n        },\n      },\n    })\n\n    if (count) {\n      aggregate.push({\n        $addFields: {\n          [`${as}.totalDocs`]: {\n            $add: aliases.map((alias) => ({\n              $ifNull: [\n                {\n                  $first: `$${as}.totalDocs.${alias}.result`,\n                },\n                0,\n              ],\n            })),\n          },\n        },\n      })\n    }\n\n    aggregate.push({\n      $set: {\n        [`${as}.docs`]: {\n          $sortArray: {\n            input: `$${as}.docs`,\n            sortBy: {\n              [sortProperty]: sortDirection,\n            },\n          },\n        },\n      },\n    })\n\n    const sliceValue = page ? [(page - 1) * limitJoin, limitJoin] : [limitJoin]\n\n    aggregate.push({\n      $addFields: {\n        [`${as}.hasNextPage`]: {\n          $gt: [{ $size: `$${as}.docs` }, limitJoin || Number.MAX_VALUE],\n        },\n      },\n    })\n\n    aggregate.push({\n      $set: {\n        [`${as}.docs`]: {\n          $slice: [`$${as}.docs`, ...sliceValue],\n        },\n      },\n    })\n  }\n\n  for (const slug of Object.keys(joinConfig)) {\n    const joinsList = joinConfig[slug]\n\n    if (!joinsList) {\n      throw new APIError(`Failed to retrieve array of joins for ${slug} in collectio ${collection}`)\n    }\n\n    for (const join of joinsList) {\n      if (projection && !projection[join.joinPath]) {\n        continue\n      }\n\n      if (joins?.[join.joinPath] === false) {\n        continue\n      }\n\n      const collectionConfig = adapter.payload.collections[join.field.collection as string]?.config\n\n      if (!collectionConfig) {\n        throw new APIError(\n          `Collection config for ${join.field.collection.toString()} was not found`,\n        )\n      }\n\n      let JoinModel: CollectionModel | undefined\n\n      const useDrafts = (draftsEnabled || versions) && Boolean(collectionConfig.versions.drafts)\n\n      if (useDrafts) {\n        JoinModel = adapter.versions[collectionConfig.slug]\n      } else {\n        JoinModel = adapter.collections[collectionConfig.slug]\n      }\n\n      if (!JoinModel) {\n        throw new APIError(`Join Model was not found for ${collectionConfig.slug}`)\n      }\n\n      const {\n        count,\n        limit: limitJoin = join.field.defaultLimit ?? 10,\n        page,\n        sort: sortJoin = join.field.defaultSort || collectionConfig.defaultSort,\n        where: whereJoin = {},\n      } = joins?.[join.joinPath] || {}\n\n      if (Array.isArray(join.field.collection)) {\n        throw new Error('Unreachable')\n      }\n\n      const fields = useDrafts\n        ? buildVersionCollectionFields(adapter.payload.config, collectionConfig, true)\n        : collectionConfig.flattenedFields\n\n      const sort = buildSortParam({\n        adapter,\n        config: adapter.payload.config,\n        fields,\n        locale,\n        sort: useDrafts ? getQueryDraftsSort({ collectionConfig, sort: sortJoin }) : sortJoin,\n        timestamps: true,\n      })\n      const sortProperty = Object.keys(sort)[0]!\n      const sortDirection = sort[sortProperty] === 'asc' ? 1 : -1\n\n      const $match = await JoinModel.buildQuery({\n        locale,\n        payload: adapter.payload,\n        where: useDrafts\n          ? combineQueries(appendVersionToQueryKey(whereJoin), {\n              latest: {\n                equals: true,\n              },\n            })\n          : whereJoin,\n      })\n\n      const pipeline: Exclude<PipelineStage, PipelineStage.Merge | PipelineStage.Out>[] = [\n        { $match },\n        {\n          $sort: { [sortProperty]: sortDirection },\n        },\n      ]\n\n      if (page) {\n        pipeline.push({\n          $skip: (page - 1) * limitJoin,\n        })\n      }\n\n      if (limitJoin > 0) {\n        pipeline.push({\n          $limit: limitJoin + 1,\n        })\n      }\n\n      let polymorphicSuffix = ''\n      if (Array.isArray(join.targetField.relationTo)) {\n        polymorphicSuffix = '.value'\n      }\n\n      const addTotalDocsAggregation = (as: string, foreignField: string) =>\n        aggregate.push(\n          {\n            $lookup: {\n              as: `${as}.totalDocs`,\n              foreignField,\n              from: JoinModel.collection.name,\n              localField: versions ? 'parent' : '_id',\n              pipeline: [\n                {\n                  $match,\n                },\n                {\n                  $count: 'result',\n                },\n              ],\n            },\n          },\n          {\n            $addFields: {\n              [`${as}.totalDocs`]: { $ifNull: [{ $first: `$${as}.totalDocs.result` }, 0] },\n            },\n          },\n        )\n\n      let foreignFieldPrefix = ''\n\n      if (useDrafts) {\n        foreignFieldPrefix = 'version.'\n      }\n\n      if (adapter.payload.config.localization && locale === 'all') {\n        adapter.payload.config.localization.localeCodes.forEach((code) => {\n          const as = `${versions ? `version.${join.joinPath}` : join.joinPath}${code}`\n\n          aggregate.push(\n            {\n              $lookup: {\n                as: `${as}.docs`,\n                foreignField: `${foreignFieldPrefix}${join.field.on}${code}${polymorphicSuffix}`,\n                from: JoinModel.collection.name,\n                localField: versions ? 'parent' : '_id',\n                pipeline,\n              },\n            },\n            {\n              $addFields: {\n                [`${as}.docs`]: {\n                  $map: {\n                    as: 'doc',\n                    in: useDrafts ? `$$doc.parent` : '$$doc._id',\n                    input: `$${as}.docs`,\n                  },\n                }, // Slicing the docs to match the limit\n                [`${as}.hasNextPage`]: limitJoin\n                  ? { $gt: [{ $size: `$${as}.docs` }, limitJoin] }\n                  : false,\n                // Boolean indicating if more docs than limit\n              },\n            },\n          )\n\n          if (limitJoin > 0) {\n            aggregate.push({\n              $addFields: {\n                [`${as}.docs`]: {\n                  $slice: [`$${as}.docs`, limitJoin],\n                },\n              },\n            })\n          }\n\n          if (count) {\n            addTotalDocsAggregation(\n              as,\n              `${foreignFieldPrefix}${join.field.on}${code}${polymorphicSuffix}`,\n            )\n          }\n        })\n      } else {\n        const localeSuffix =\n          fieldShouldBeLocalized({\n            field: join.field,\n            parentIsLocalized: join.parentIsLocalized,\n          }) &&\n          adapter.payload.config.localization &&\n          locale\n            ? `.${locale}`\n            : ''\n        const as = `${versions ? `version.${join.joinPath}` : join.joinPath}${localeSuffix}`\n\n        let foreignField: string\n\n        if (join.getForeignPath) {\n          foreignField = `${join.getForeignPath({ locale })}${polymorphicSuffix}`\n        } else {\n          foreignField = `${join.field.on}${polymorphicSuffix}`\n        }\n\n        aggregate.push(\n          {\n            $lookup: {\n              as: `${as}.docs`,\n              foreignField: `${foreignFieldPrefix}${foreignField}`,\n              from: JoinModel.collection.name,\n              localField: versions ? 'parent' : '_id',\n              pipeline,\n            },\n          },\n          {\n            $addFields: {\n              [`${as}.docs`]: {\n                $map: {\n                  as: 'doc',\n                  in: useDrafts ? `$$doc.parent` : '$$doc._id',\n                  input: `$${as}.docs`,\n                },\n              }, // Slicing the docs to match the limit\n              [`${as}.hasNextPage`]: {\n                $gt: [{ $size: `$${as}.docs` }, limitJoin || Number.MAX_VALUE],\n              }, // Boolean indicating if more docs than limit\n            },\n          },\n        )\n\n        if (count) {\n          addTotalDocsAggregation(as, `${foreignFieldPrefix}${foreignField}`)\n        }\n\n        if (limitJoin > 0) {\n          aggregate.push({\n            $addFields: {\n              [`${as}.docs`]: {\n                $slice: [`$${as}.docs`, limitJoin],\n              },\n            },\n          })\n        }\n      }\n    }\n  }\n\n  return aggregate\n}\n"],"names":["APIError","appendVersionToQueryKey","buildVersionCollectionFields","combineQueries","getQueryDraftsSort","fieldShouldBeLocalized","buildQuery","buildSortParam","getCollection","buildJoinAggregation","adapter","collection","collectionConfig","draftsEnabled","joins","locale","projection","versions","useJoinAggregations","Object","keys","length","polymorphicJoins","joinConfig","payload","collections","config","aggregate","polymorphicJoinsConfig","join","joinPath","count","limit","limitJoin","field","defaultLimit","page","sort","sortJoin","defaultSort","where","whereJoin","aggregatedFields","collectionSlug","flattenedFields","some","eachField","name","push","fields","timestamps","$match","sortProperty","sortDirection","projectSort","aliases","as","alias","basePipeline","$addFields","relationTo","$literal","$and","$expr","$eq","on","Model","JoinModel","$lookup","from","let","root_id_","pipeline","$sort","$limit","$project","value","$count","$concatArrays","map","$add","$ifNull","$first","$set","$sortArray","input","sortBy","sliceValue","$gt","$size","Number","MAX_VALUE","$slice","slug","joinsList","toString","useDrafts","Boolean","drafts","Array","isArray","Error","latest","equals","$skip","polymorphicSuffix","targetField","addTotalDocsAggregation","foreignField","localField","foreignFieldPrefix","localization","localeCodes","forEach","code","$map","in","localeSuffix","parentIsLocalized","getForeignPath"],"mappings":"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"}