{"version":3,"sources":["../../src/utilities/resolveJoins.ts"],"sourcesContent":["import type { JoinQuery, SanitizedJoins, Where } from 'payload'\n\nimport {\n  appendVersionToQueryKey,\n  buildVersionCollectionFields,\n  combineQueries,\n  getQueryDraftsSort,\n} from 'payload'\nimport { fieldShouldBeLocalized } from 'payload/shared'\n\nimport type { MongooseAdapter } from '../index.js'\n\nimport { buildQuery } from '../queries/buildQuery.js'\nimport { buildSortParam } from '../queries/buildSortParam.js'\nimport { transform } from './transform.js'\n\nexport type ResolveJoinsArgs = {\n  /** The MongoDB adapter instance */\n  adapter: MongooseAdapter\n  /** The slug of the collection being queried */\n  collectionSlug: string\n  /** Array of documents to resolve joins for */\n  docs: Record<string, unknown>[]\n  /** Join query specifications (which joins to resolve and how) */\n  joins?: JoinQuery\n  /** Optional locale for localized queries */\n  locale?: string\n  /** Optional projection for the join query */\n  projection?: Record<string, true>\n  /** Whether to resolve versions instead of published documents */\n  versions?: boolean\n}\n\n/**\n * Resolves join relationships for a collection of documents.\n * This function fetches related documents based on join configurations and\n * attaches them to the original documents with pagination support.\n */\nexport async function resolveJoins({\n  adapter,\n  collectionSlug,\n  docs,\n  joins,\n  locale,\n  projection,\n  versions = false,\n}: ResolveJoinsArgs): Promise<void> {\n  // Early return if no joins are specified or no documents to process\n  if (!joins || docs.length === 0) {\n    return\n  }\n\n  // Get the collection configuration from the adapter\n  const collectionConfig = adapter.payload.collections[collectionSlug]?.config\n  if (!collectionConfig) {\n    return\n  }\n\n  // Build a map of join paths to their configurations for quick lookup\n  // This flattens the nested join structure into a single map keyed by join path\n  const joinMap: Record<string, { targetCollection: string } & SanitizedJoin> = {}\n\n  // Add regular joins\n  for (const [target, joinList] of Object.entries(collectionConfig.joins)) {\n    for (const join of joinList) {\n      joinMap[join.joinPath] = { ...join, targetCollection: target }\n    }\n  }\n\n  // Add polymorphic joins\n  for (const join of collectionConfig.polymorphicJoins || []) {\n    // For polymorphic joins, we use the collections array as the target\n    joinMap[join.joinPath] = { ...join, targetCollection: join.field.collection as string }\n  }\n\n  // Process each requested join concurrently\n  const joinPromises = Object.entries(joins).map(async ([joinPath, joinQuery]) => {\n    if (!joinQuery) {\n      return null\n    }\n\n    // If a projection is provided, and the join path is not in the projection, skip it\n    if (projection && !projection[joinPath]) {\n      return null\n    }\n\n    // Get the join definition from our map\n    const joinDef = joinMap[joinPath]\n    if (!joinDef) {\n      return null\n    }\n\n    // Normalize collections to always be an array for unified processing\n    const allCollections = Array.isArray(joinDef.field.collection)\n      ? joinDef.field.collection\n      : [joinDef.field.collection]\n\n    // Use the provided locale or fall back to the default locale for localized fields\n    const localizationConfig = adapter.payload.config.localization\n    const effectiveLocale =\n      locale ||\n      (typeof localizationConfig === 'object' &&\n        localizationConfig &&\n        localizationConfig.defaultLocale)\n\n    // Extract relationTo filter from the where clause to determine which collections to query\n    const relationToFilter = extractRelationToFilter(joinQuery.where || {})\n\n    // Determine which collections to query based on relationTo filter\n    const collections = relationToFilter\n      ? allCollections.filter((col) => relationToFilter.includes(col))\n      : allCollections\n\n    // Check if this is a polymorphic collection join (where field.collection is an array)\n    const isPolymorphicJoin = Array.isArray(joinDef.field.collection)\n\n    // Apply pagination settings\n    const limit = joinQuery.limit ?? joinDef.field.defaultLimit ?? 10\n    const page = joinQuery.page ?? 1\n    const skip = (page - 1) * limit\n\n    // Process collections concurrently\n    const collectionPromises = collections.map(async (joinCollectionSlug) => {\n      const targetConfig = adapter.payload.collections[joinCollectionSlug]?.config\n      if (!targetConfig) {\n        return null\n      }\n\n      const useDrafts = versions && Boolean(targetConfig.versions?.drafts)\n      let JoinModel\n      if (useDrafts) {\n        JoinModel = adapter.versions[targetConfig.slug]\n      } else {\n        JoinModel = adapter.collections[targetConfig.slug]\n      }\n\n      if (!JoinModel) {\n        return null\n      }\n\n      // Extract all parent document IDs to use in the join query\n      const parentIDs = docs.map((d) => (versions ? (d.parent ?? d._id ?? d.id) : (d._id ?? d.id)))\n\n      // Build the base query\n      let whereQuery: null | Record<string, unknown> = null\n      whereQuery = isPolymorphicJoin\n        ? filterWhereForCollection(\n            joinQuery.where || {},\n            targetConfig.flattenedFields,\n            true, // exclude relationTo for individual collections\n          )\n        : joinQuery.where || {}\n\n      // Skip this collection if the WHERE clause cannot be satisfied for polymorphic collection joins\n      if (whereQuery === null) {\n        return null\n      }\n      whereQuery = useDrafts\n        ? await JoinModel.buildQuery({\n            locale,\n            payload: adapter.payload,\n            where: combineQueries(appendVersionToQueryKey(whereQuery as Where), {\n              latest: {\n                equals: true,\n              },\n            }),\n          })\n        : await buildQuery({\n            adapter,\n            collectionSlug: joinCollectionSlug,\n            fields: targetConfig.flattenedFields,\n            locale,\n            where: whereQuery as Where,\n          })\n\n      // Handle localized paths and version prefixes\n      let dbFieldName = joinDef.field.on\n\n      if (effectiveLocale && typeof localizationConfig === 'object' && localizationConfig) {\n        const pathSegments = joinDef.field.on.split('.')\n        const transformedSegments: string[] = []\n        const fields = useDrafts\n          ? buildVersionCollectionFields(adapter.payload.config, targetConfig, true)\n          : targetConfig.flattenedFields\n\n        for (let i = 0; i < pathSegments.length; i++) {\n          const segment = pathSegments[i]!\n          transformedSegments.push(segment)\n\n          // Check if this segment corresponds to a localized field\n          const fieldAtSegment = fields.find((f) => f.name === segment)\n          if (fieldAtSegment && fieldAtSegment.localized) {\n            transformedSegments.push(effectiveLocale)\n          }\n        }\n\n        dbFieldName = transformedSegments.join('.')\n      }\n\n      // Add version prefix for draft queries\n      if (useDrafts) {\n        dbFieldName = `version.${dbFieldName}`\n      }\n\n      // Check if the target field is a polymorphic relationship\n      const isPolymorphic = joinDef.targetField\n        ? Array.isArray(joinDef.targetField.relationTo)\n        : false\n\n      if (isPolymorphic) {\n        // For polymorphic relationships, we need to match both relationTo and value\n        whereQuery[`${dbFieldName}.relationTo`] = collectionSlug\n        whereQuery[`${dbFieldName}.value`] = { $in: parentIDs }\n      } else {\n        // For regular relationships and polymorphic collection joins\n        whereQuery[dbFieldName] = { $in: parentIDs }\n      }\n\n      // Build the sort parameters for the query\n      const fields = useDrafts\n        ? buildVersionCollectionFields(adapter.payload.config, targetConfig, true)\n        : targetConfig.flattenedFields\n\n      const sort = buildSortParam({\n        adapter,\n        config: adapter.payload.config,\n        fields,\n        locale,\n        sort: useDrafts\n          ? getQueryDraftsSort({\n              collectionConfig: targetConfig,\n              sort: joinQuery.sort || joinDef.field.defaultSort || targetConfig.defaultSort,\n            })\n          : joinQuery.sort || joinDef.field.defaultSort || targetConfig.defaultSort,\n        timestamps: true,\n      })\n\n      const projection = buildJoinProjection(dbFieldName, useDrafts, sort)\n\n      const [results, dbCount] = await Promise.all([\n        JoinModel.find(whereQuery, projection, {\n          sort,\n          ...(isPolymorphicJoin ? {} : { limit, skip }),\n        }).lean(),\n        isPolymorphicJoin ? Promise.resolve(0) : JoinModel.countDocuments(whereQuery),\n      ])\n\n      const count = isPolymorphicJoin ? results.length : dbCount\n\n      transform({\n        adapter,\n        data: results,\n        fields: useDrafts\n          ? buildVersionCollectionFields(adapter.payload.config, targetConfig, false)\n          : targetConfig.fields,\n        operation: 'read',\n      })\n\n      // Return results with collection info for grouping\n      return {\n        collectionSlug: joinCollectionSlug,\n        count,\n        dbFieldName,\n        results,\n        sort,\n        useDrafts,\n      }\n    })\n\n    const collectionResults = await Promise.all(collectionPromises)\n\n    // Group the results by parent ID\n    const grouped: Record<\n      string,\n      {\n        docs: Record<string, unknown>[]\n        sort: Record<string, string>\n      }\n    > = {}\n\n    let totalCount = 0\n    for (const collectionResult of collectionResults) {\n      if (!collectionResult) {\n        continue\n      }\n\n      const { collectionSlug, count, dbFieldName, results, sort, useDrafts } = collectionResult\n\n      totalCount += count\n\n      for (const result of results) {\n        if (useDrafts) {\n          result.id = result.parent\n        }\n\n        const parentValues = getByPathWithArrays(result, dbFieldName) as (\n          | { relationTo: string; value: number | string }\n          | number\n          | string\n        )[]\n\n        if (parentValues.length === 0) {\n          continue\n        }\n\n        for (let parentValue of parentValues) {\n          if (!parentValue) {\n            continue\n          }\n\n          if (typeof parentValue === 'object') {\n            parentValue = parentValue.value\n          }\n\n          const joinData = {\n            relationTo: collectionSlug,\n            value: result.id,\n          }\n\n          const parentKey = parentValue as string\n          if (!grouped[parentKey]) {\n            grouped[parentKey] = {\n              docs: [],\n              sort,\n            }\n          }\n\n          // Always store the ObjectID reference in polymorphic format\n          grouped[parentKey].docs.push({\n            ...result,\n            __joinData: joinData,\n          })\n        }\n      }\n    }\n\n    for (const results of Object.values(grouped)) {\n      results.docs.sort((a, b) => {\n        for (const [fieldName, sortOrder] of Object.entries(results.sort)) {\n          const sort = sortOrder === 'asc' ? 1 : -1\n          const aValue = a[fieldName] as Date | number | string\n          const bValue = b[fieldName] as Date | number | string\n          if (aValue < bValue) {\n            return -1 * sort\n          }\n          if (aValue > bValue) {\n            return 1 * sort\n          }\n        }\n        return 0\n      })\n      results.docs = results.docs.map(\n        (doc) => (isPolymorphicJoin ? doc.__joinData : doc.id) as Record<string, unknown>,\n      )\n    }\n\n    // Determine if the join field should be localized\n    const localeSuffix =\n      fieldShouldBeLocalized({\n        field: joinDef.field,\n        parentIsLocalized: joinDef.parentIsLocalized,\n      }) &&\n      adapter.payload.config.localization &&\n      effectiveLocale\n        ? `.${effectiveLocale}`\n        : ''\n\n    // Adjust the join path with locale suffix if needed\n    const localizedJoinPath = `${joinPath}${localeSuffix}`\n\n    return {\n      grouped,\n      isPolymorphicJoin,\n      joinQuery,\n      limit,\n      localizedJoinPath,\n      page,\n      skip,\n      totalCount,\n    }\n  })\n\n  // Wait for all join operations to complete\n  const joinResults = await Promise.all(joinPromises)\n\n  // Process the results and attach them to documents\n  for (const joinResult of joinResults) {\n    if (!joinResult) {\n      continue\n    }\n\n    const { grouped, isPolymorphicJoin, joinQuery, limit, localizedJoinPath, skip, totalCount } =\n      joinResult\n\n    // Attach the joined data to each parent document\n    for (const doc of docs) {\n      const id = (versions ? (doc.parent ?? doc._id ?? doc.id) : (doc._id ?? doc.id)) as string\n      const all = grouped[id]?.docs || []\n\n      // Calculate the slice for pagination\n      // When limit is 0, it means unlimited - return all results\n      const slice = isPolymorphicJoin\n        ? limit === 0\n          ? all\n          : all.slice(skip, skip + limit)\n        : // For non-polymorphic joins, we assume that page and limit were applied at the database level\n          all\n\n      // Create the join result object with pagination metadata\n      const value: Record<string, unknown> = {\n        docs: slice,\n        hasNextPage: limit === 0 ? false : totalCount > skip + slice.length,\n      }\n\n      // Include total count if requested\n      if (joinQuery.count) {\n        value.totalDocs = totalCount\n      }\n\n      // Navigate to the correct nested location in the document and set the join data\n      // This handles nested join paths like \"user.posts\" by creating intermediate objects\n      const segments = localizedJoinPath.split('.')\n      let ref: Record<string, unknown>\n      if (versions) {\n        if (!doc.version) {\n          doc.version = {}\n        }\n        ref = doc.version as Record<string, unknown>\n      } else {\n        ref = doc\n      }\n\n      for (let i = 0; i < segments.length - 1; i++) {\n        const seg = segments[i]!\n        if (!ref[seg]) {\n          ref[seg] = {}\n        }\n        ref = ref[seg] as Record<string, unknown>\n      }\n      // Set the final join data at the target path\n      ref[segments[segments.length - 1]!] = value\n    }\n  }\n}\n\n/**\n * Extracts relationTo filter values from a WHERE clause\n *\n * @purpose When you have a polymorphic join field that can reference multiple collection types (e.g. the documentsAndFolders join field on\n * folders that points to all folder-enabled collections), Payload needs to decide which collections to actually query. Without filtering,\n * it would query ALL possible collections even when the WHERE clause clearly indicates it only needs specific ones.\n *\n * extractRelationToFilter analyzes the WHERE clause to extract relationTo conditions and returns only the collection slugs that\n * could possibly match, avoiding unnecessary database queries.\n *\n * @description The function recursively traverses a WHERE clause looking for relationTo conditions in these patterns:\n *\n * 1. Direct conditions: { relationTo: { equals: 'posts' } }\n * 2. IN conditions: { relationTo: { in: ['posts', 'media'] } }\n * 3. Nested in AND/OR: Recursively searches through logical operators\n\n * @param where - The WHERE clause to search\n * @returns Array of collection slugs if relationTo filter found, null otherwise\n */\nfunction extractRelationToFilter(where: Record<string, unknown>): null | string[] {\n  if (!where || typeof where !== 'object') {\n    return null\n  }\n\n  // Check for direct relationTo conditions\n  if (where.relationTo && typeof where.relationTo === 'object') {\n    const relationTo = where.relationTo as Record<string, unknown>\n    if (relationTo.in && Array.isArray(relationTo.in)) {\n      return relationTo.in as string[]\n    }\n    if (relationTo.equals) {\n      return [relationTo.equals as string]\n    }\n  }\n\n  // Check for relationTo in logical operators\n  if (where.and && Array.isArray(where.and)) {\n    const allResults: string[] = []\n    for (const condition of where.and) {\n      const result = extractRelationToFilter(condition)\n      if (result) {\n        allResults.push(...result)\n      }\n    }\n    if (allResults.length > 0) {\n      return [...new Set(allResults)] // Remove duplicates\n    }\n  }\n\n  if (where.or && Array.isArray(where.or)) {\n    const allResults: string[] = []\n    for (const condition of where.or) {\n      const result = extractRelationToFilter(condition)\n      if (result) {\n        allResults.push(...result)\n      }\n    }\n    if (allResults.length > 0) {\n      return [...new Set(allResults)] // Remove duplicates\n    }\n  }\n\n  return null\n}\n\n/**\n * Filters a WHERE clause to only include fields that exist in the target collection\n * This is needed for polymorphic joins where different collections have different fields\n * @param where - The original WHERE clause\n * @param availableFields - The fields available in the target collection\n * @param excludeRelationTo - Whether to exclude relationTo field (for individual collections)\n * @returns A filtered WHERE clause, or null if the query cannot match this collection\n */\nfunction filterWhereForCollection(\n  where: Record<string, unknown>,\n  availableFields: Array<{ name: string }>,\n  excludeRelationTo: boolean = false,\n): null | Record<string, unknown> {\n  if (!where || typeof where !== 'object') {\n    return where\n  }\n\n  const fieldNames = new Set(availableFields.map((f) => f.name))\n  // Add special fields that are available in polymorphic relationships\n  if (!excludeRelationTo) {\n    fieldNames.add('relationTo')\n  }\n\n  const filtered: Record<string, unknown> = {}\n\n  for (const [key, value] of Object.entries(where)) {\n    if (key === 'and') {\n      // Handle AND operator - all conditions must be satisfiable\n      if (Array.isArray(value)) {\n        const filteredConditions: Record<string, unknown>[] = []\n\n        for (const condition of value) {\n          const filteredCondition = filterWhereForCollection(\n            condition,\n            availableFields,\n            excludeRelationTo,\n          )\n\n          // If any condition in AND cannot be satisfied, the whole AND fails\n          if (filteredCondition === null) {\n            return null\n          }\n\n          if (Object.keys(filteredCondition).length > 0) {\n            filteredConditions.push(filteredCondition)\n          }\n        }\n\n        if (filteredConditions.length > 0) {\n          filtered[key] = filteredConditions\n        }\n      }\n    } else if (key === 'or') {\n      // Handle OR operator - at least one condition must be satisfiable\n      if (Array.isArray(value)) {\n        const filteredConditions = value\n          .map((condition) =>\n            filterWhereForCollection(condition, availableFields, excludeRelationTo),\n          )\n          .filter((condition) => condition !== null && Object.keys(condition).length > 0)\n\n        if (filteredConditions.length > 0) {\n          filtered[key] = filteredConditions\n        }\n        // If no OR conditions can be satisfied, we still continue (OR is more permissive)\n      }\n    } else if (key === 'relationTo' && excludeRelationTo) {\n      // Skip relationTo field for non-polymorphic collections\n      continue\n    } else if (fieldNames.has(key)) {\n      // Include the condition if the field exists in this collection\n      filtered[key] = value\n    } else {\n      // Field doesn't exist in this collection - this makes the query unsatisfiable\n      return null\n    }\n  }\n\n  return filtered\n}\n\ntype SanitizedJoin = SanitizedJoins[string][number]\n\n/**\n * Builds projection for join queries\n */\nfunction buildJoinProjection(\n  baseFieldName: string,\n  useDrafts: boolean,\n  sort: Record<string, string>,\n): Record<string, 1> {\n  const projection: Record<string, 1> = {\n    _id: 1,\n    [baseFieldName]: 1,\n  }\n\n  if (useDrafts) {\n    projection.parent = 1\n  }\n\n  for (const fieldName of Object.keys(sort)) {\n    projection[fieldName] = 1\n  }\n\n  return projection\n}\n\n/**\n * Enhanced utility function to safely traverse nested object properties using dot notation\n * Handles arrays by searching through array elements for matching values\n * @param doc - The document to traverse\n * @param path - Dot-separated path (e.g., \"array.category\")\n * @returns Array of values found at the specified path (for arrays) or single value\n */\nfunction getByPathWithArrays(doc: unknown, path: string): unknown[] {\n  const segments = path.split('.')\n  let current = doc\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i]!\n\n    if (current === undefined || current === null) {\n      return []\n    }\n\n    // Get the value at the current segment\n    const value = (current as Record<string, unknown>)[segment]\n\n    if (value === undefined || value === null) {\n      return []\n    }\n\n    // If this is the last segment, return the value(s)\n    if (i === segments.length - 1) {\n      return Array.isArray(value) ? value : [value]\n    }\n\n    // If the value is an array and we have more segments to traverse\n    if (Array.isArray(value)) {\n      const remainingPath = segments.slice(i + 1).join('.')\n      const results: unknown[] = []\n\n      // Search through each array element\n      for (const item of value) {\n        if (item && typeof item === 'object') {\n          const subResults = getByPathWithArrays(item, remainingPath)\n          results.push(...subResults)\n        }\n      }\n\n      return results\n    }\n\n    // Continue traversing\n    current = value\n  }\n\n  return []\n}\n"],"names":["appendVersionToQueryKey","buildVersionCollectionFields","combineQueries","getQueryDraftsSort","fieldShouldBeLocalized","buildQuery","buildSortParam","transform","resolveJoins","adapter","collectionSlug","docs","joins","locale","projection","versions","length","collectionConfig","payload","collections","config","joinMap","target","joinList","Object","entries","join","joinPath","targetCollection","polymorphicJoins","field","collection","joinPromises","map","joinQuery","joinDef","allCollections","Array","isArray","localizationConfig","localization","effectiveLocale","defaultLocale","relationToFilter","extractRelationToFilter","where","filter","col","includes","isPolymorphicJoin","limit","defaultLimit","page","skip","collectionPromises","joinCollectionSlug","targetConfig","useDrafts","Boolean","drafts","JoinModel","slug","parentIDs","d","parent","_id","id","whereQuery","filterWhereForCollection","flattenedFields","latest","equals","fields","dbFieldName","on","pathSegments","split","transformedSegments","i","segment","push","fieldAtSegment","find","f","name","localized","isPolymorphic","targetField","relationTo","$in","sort","defaultSort","timestamps","buildJoinProjection","results","dbCount","Promise","all","lean","resolve","countDocuments","count","data","operation","collectionResults","grouped","totalCount","collectionResult","result","parentValues","getByPathWithArrays","parentValue","value","joinData","parentKey","__joinData","values","a","b","fieldName","sortOrder","aValue","bValue","doc","localeSuffix","parentIsLocalized","localizedJoinPath","joinResults","joinResult","slice","hasNextPage","totalDocs","segments","ref","version","seg","in","and","allResults","condition","Set","or","availableFields","excludeRelationTo","fieldNames","add","filtered","key","filteredConditions","filteredCondition","keys","has","baseFieldName","path","current","undefined","remainingPath","item","subResults"],"mappings":"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"}