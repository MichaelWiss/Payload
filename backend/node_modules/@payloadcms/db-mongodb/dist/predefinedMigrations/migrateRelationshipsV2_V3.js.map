{"version":3,"sources":["../../src/predefinedMigrations/migrateRelationshipsV2_V3.ts"],"sourcesContent":["import type { ClientSession, Model } from 'mongoose'\nimport type { Field, PayloadRequest } from 'payload'\n\nimport { buildVersionCollectionFields, buildVersionGlobalFields } from 'payload'\n\nimport type { MongooseAdapter } from '../index.js'\n\nimport { getCollection, getGlobal } from '../utilities/getEntity.js'\nimport { getSession } from '../utilities/getSession.js'\nimport { transform } from '../utilities/transform.js'\n\nconst migrateModelWithBatching = async ({\n  batchSize,\n  db,\n  fields,\n  Model,\n  parentIsLocalized,\n  session,\n}: {\n  batchSize: number\n  db: MongooseAdapter\n  fields: Field[]\n  Model: Model<any>\n  parentIsLocalized: boolean\n  session?: ClientSession\n}): Promise<void> => {\n  let hasNext = true\n  let skip = 0\n\n  while (hasNext) {\n    const docs = await Model.find(\n      {},\n      {},\n      {\n        lean: true,\n        limit: batchSize + 1,\n        session,\n        skip,\n      },\n    )\n\n    if (docs.length === 0) {\n      break\n    }\n\n    hasNext = docs.length > batchSize\n\n    if (hasNext) {\n      docs.pop()\n    }\n\n    for (const doc of docs) {\n      transform({ adapter: db, data: doc, fields, operation: 'write', parentIsLocalized })\n    }\n\n    await Model.collection.bulkWrite(\n      // @ts-expect-error bulkWrite has a weird type, insertOne, updateMany etc are required here as well.\n      docs.map((doc) => ({\n        updateOne: {\n          filter: { _id: doc._id },\n          update: {\n            $set: doc,\n          },\n        },\n      })),\n      {\n        session, // Timestamps are manually added by the write transform\n        timestamps: false,\n      },\n    )\n\n    skip += batchSize\n  }\n}\n\nconst hasRelationshipOrUploadField = ({ fields }: { fields: Field[] }): boolean => {\n  for (const field of fields) {\n    if (field.type === 'relationship' || field.type === 'upload') {\n      return true\n    }\n\n    if ('fields' in field) {\n      if (hasRelationshipOrUploadField({ fields: field.fields })) {\n        return true\n      }\n    }\n\n    if ('blocks' in field) {\n      for (const block of field.blocks) {\n        if (typeof block === 'string') {\n          // Skip - string blocks have been added in v3 and thus don't need to be migrated\n          continue\n        }\n        if (hasRelationshipOrUploadField({ fields: block.fields })) {\n          return true\n        }\n      }\n    }\n\n    if ('tabs' in field) {\n      for (const tab of field.tabs) {\n        if (hasRelationshipOrUploadField({ fields: tab.fields })) {\n          return true\n        }\n      }\n    }\n  }\n\n  return false\n}\n\nexport async function migrateRelationshipsV2_V3({\n  batchSize,\n  req,\n}: {\n  batchSize: number\n  req: PayloadRequest\n}): Promise<void> {\n  const { payload } = req\n  const db = payload.db as MongooseAdapter\n  const config = payload.config\n\n  const session = await getSession(db, req)\n\n  for (const collection of payload.config.collections) {\n    if (hasRelationshipOrUploadField(collection)) {\n      payload.logger.info(`Migrating collection \"${collection.slug}\"`)\n\n      const { Model } = getCollection({ adapter: db, collectionSlug: collection.slug })\n\n      await migrateModelWithBatching({\n        batchSize,\n        db,\n        fields: collection.fields,\n        Model,\n        parentIsLocalized: false,\n        session,\n      })\n\n      payload.logger.info(`Migrated collection \"${collection.slug}\"`)\n    }\n\n    if (collection.versions) {\n      payload.logger.info(`Migrating collection versions \"${collection.slug}\"`)\n\n      const { Model } = getCollection({\n        adapter: db,\n        collectionSlug: collection.slug,\n        versions: true,\n      })\n\n      await migrateModelWithBatching({\n        batchSize,\n        db,\n        fields: buildVersionCollectionFields(config, collection),\n        Model,\n        parentIsLocalized: false,\n        session,\n      })\n\n      payload.logger.info(`Migrated collection versions \"${collection.slug}\"`)\n    }\n  }\n\n  const { globals: GlobalsModel } = db\n\n  for (const global of payload.config.globals) {\n    if (hasRelationshipOrUploadField(global)) {\n      payload.logger.info(`Migrating global \"${global.slug}\"`)\n\n      const doc = await GlobalsModel.findOne<Record<string, unknown>>(\n        {\n          globalType: {\n            $eq: global.slug,\n          },\n        },\n        {},\n        { lean: true, session },\n      )\n\n      // in case if the global doesn't exist in the database yet  (not saved)\n      if (doc) {\n        transform({\n          adapter: db,\n          data: doc,\n          fields: global.fields,\n          operation: 'write',\n        })\n\n        await GlobalsModel.collection.updateOne(\n          {\n            globalType: global.slug,\n          },\n          { $set: doc },\n          { session },\n        )\n      }\n\n      payload.logger.info(`Migrated global \"${global.slug}\"`)\n    }\n\n    if (global.versions) {\n      payload.logger.info(`Migrating global versions \"${global.slug}\"`)\n\n      const { Model } = getGlobal({ adapter: db, globalSlug: global.slug, versions: true })\n\n      await migrateModelWithBatching({\n        batchSize,\n        db,\n        fields: buildVersionGlobalFields(config, global),\n        Model,\n        parentIsLocalized: false,\n        session,\n      })\n\n      payload.logger.info(`Migrated global versions \"${global.slug}\"`)\n    }\n  }\n}\n"],"names":["buildVersionCollectionFields","buildVersionGlobalFields","getCollection","getGlobal","getSession","transform","migrateModelWithBatching","batchSize","db","fields","Model","parentIsLocalized","session","hasNext","skip","docs","find","lean","limit","length","pop","doc","adapter","data","operation","collection","bulkWrite","map","updateOne","filter","_id","update","$set","timestamps","hasRelationshipOrUploadField","field","type","block","blocks","tab","tabs","migrateRelationshipsV2_V3","req","payload","config","collections","logger","info","slug","collectionSlug","versions","globals","GlobalsModel","global","findOne","globalType","$eq","globalSlug"],"mappings":"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"}