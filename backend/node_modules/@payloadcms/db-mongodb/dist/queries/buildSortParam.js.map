{"version":3,"sources":["../../src/queries/buildSortParam.ts"],"sourcesContent":["import type { PipelineStage } from 'mongoose'\n\nimport {\n  APIError,\n  type FlattenedField,\n  getFieldByPath,\n  type SanitizedConfig,\n  type Sort,\n} from 'payload'\n\nimport type { MongooseAdapter } from '../index.js'\n\nimport { getCollection } from '../utilities/getEntity.js'\nimport { getLocalizedSortProperty } from './getLocalizedSortProperty.js'\n\ntype Args = {\n  adapter: MongooseAdapter\n  config: SanitizedConfig\n  fields: FlattenedField[]\n  locale?: string\n  parentIsLocalized?: boolean\n  sort?: Sort\n  sortAggregation?: PipelineStage[]\n  timestamps: boolean\n  versions?: boolean\n}\n\nexport type SortArgs = {\n  direction: SortDirection\n  property: string\n}[]\n\nexport type SortDirection = 'asc' | 'desc'\n\nconst relationshipSort = ({\n  adapter,\n  fields,\n  locale,\n  path,\n  previousField = '',\n  sortAggregation,\n}: {\n  adapter: MongooseAdapter\n  fields: FlattenedField[]\n  locale?: string\n  path: string\n  previousField?: string\n  sortAggregation: PipelineStage[]\n  versions?: boolean\n}): null | string => {\n  let currentFields = fields\n  const segments = path.split('.')\n  if (segments.length < 2) {\n    return null\n  }\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i]\n    const field = currentFields.find((each) => each.name === segment)\n\n    if (!field) {\n      return null\n    }\n\n    if ('fields' in field) {\n      currentFields = field.flattenedFields\n    } else if (\n      (field.type === 'relationship' || field.type === 'upload') &&\n      i !== segments.length - 1\n    ) {\n      const relationshipPath = segments.slice(0, i + 1).join('.')\n      const nextPath = segments.slice(i + 1, segments.length)\n      const relationshipFieldResult = getFieldByPath({ fields, path: relationshipPath })\n\n      if (\n        !relationshipFieldResult ||\n        !('relationTo' in relationshipFieldResult.field) ||\n        typeof relationshipFieldResult.field.relationTo !== 'string'\n      ) {\n        return null\n      }\n\n      const { collectionConfig, Model } = getCollection({\n        adapter,\n        collectionSlug: relationshipFieldResult.field.relationTo,\n      })\n\n      let localizedRelationshipPath: string = relationshipFieldResult.localizedPath\n\n      if (locale && relationshipFieldResult.pathHasLocalized) {\n        localizedRelationshipPath = relationshipFieldResult.localizedPath.replace(\n          '<locale>',\n          locale,\n        )\n      }\n\n      if (nextPath.join('.') === 'id') {\n        return `${previousField}${localizedRelationshipPath}`\n      }\n\n      const as = `__${previousField}${localizedRelationshipPath}`\n\n      sortAggregation.push({\n        $lookup: {\n          as: `__${previousField}${localizedRelationshipPath}`,\n          foreignField: '_id',\n          from: Model.collection.name,\n          localField: `${previousField}${localizedRelationshipPath}`,\n        },\n      })\n\n      if (nextPath.length > 1) {\n        const nextRes = relationshipSort({\n          adapter,\n          fields: collectionConfig.flattenedFields,\n          locale,\n          path: nextPath.join('.'),\n          previousField: `${as}.`,\n          sortAggregation,\n        })\n\n        if (nextRes) {\n          return nextRes\n        }\n\n        return `${as}.${nextPath.join('.')}`\n      }\n\n      const nextField = getFieldByPath({\n        fields: collectionConfig.flattenedFields,\n        path: nextPath[0]!,\n      })\n\n      if (nextField && nextField.pathHasLocalized && locale) {\n        return `${as}.${nextField.localizedPath.replace('<locale>', locale)}`\n      }\n\n      return `${as}.${nextPath[0]}`\n    }\n  }\n\n  return null\n}\n\nexport const buildSortParam = ({\n  adapter,\n  config,\n  fields,\n  locale,\n  parentIsLocalized = false,\n  sort,\n  sortAggregation,\n  timestamps,\n  versions,\n}: Args): Record<string, string> => {\n  if (!sort) {\n    if (timestamps) {\n      sort = '-createdAt'\n    } else {\n      sort = '-id'\n    }\n  }\n\n  if (typeof sort === 'string') {\n    sort = [sort]\n  }\n\n  // We use this flag to determine if the sort is unique or not to decide whether to add a fallback sort.\n  const isUniqueSort = sort.some((item) => {\n    const field = getFieldByPath({ fields, path: item })\n    return field?.field?.unique\n  })\n\n  // In the case of Mongo, when sorting by a field that is not unique, the results are not guaranteed to be in the same order each time.\n  // So we add a fallback sort to ensure that the results are always in the same order.\n  let fallbackSort = '-id'\n\n  if (timestamps) {\n    fallbackSort = '-createdAt'\n  }\n\n  const includeFallbackSort =\n    !adapter.disableFallbackSort &&\n    !isUniqueSort &&\n    !(sort.includes(fallbackSort) || sort.includes(fallbackSort.replace('-', '')))\n\n  if (includeFallbackSort) {\n    sort.push(fallbackSort)\n  }\n\n  const sorting = sort.reduce<Record<string, string>>((acc, item) => {\n    let sortProperty: string\n    let sortDirection: SortDirection\n    if (item.indexOf('-') === 0) {\n      sortProperty = item.substring(1)\n      sortDirection = 'desc'\n    } else {\n      sortProperty = item\n      sortDirection = 'asc'\n    }\n    if (sortProperty === 'id') {\n      acc['_id'] = sortDirection\n      return acc\n    }\n\n    if (sortAggregation) {\n      const sortRelProperty = relationshipSort({\n        adapter,\n        fields,\n        locale,\n        path: sortProperty,\n        sortAggregation,\n        versions,\n      })\n\n      if (sortRelProperty) {\n        acc[sortRelProperty] = sortDirection\n        return acc\n      }\n    }\n\n    const localizedProperty = getLocalizedSortProperty({\n      config,\n      fields,\n      locale,\n      parentIsLocalized,\n      segments: sortProperty.split('.'),\n    })\n    acc[localizedProperty] = sortDirection\n\n    return acc\n  }, {})\n\n  return sorting\n}\n"],"names":["getFieldByPath","getCollection","getLocalizedSortProperty","relationshipSort","adapter","fields","locale","path","previousField","sortAggregation","currentFields","segments","split","length","i","segment","field","find","each","name","flattenedFields","type","relationshipPath","slice","join","nextPath","relationshipFieldResult","relationTo","collectionConfig","Model","collectionSlug","localizedRelationshipPath","localizedPath","pathHasLocalized","replace","as","push","$lookup","foreignField","from","collection","localField","nextRes","nextField","buildSortParam","config","parentIsLocalized","sort","timestamps","versions","isUniqueSort","some","item","unique","fallbackSort","includeFallbackSort","disableFallbackSort","includes","sorting","reduce","acc","sortProperty","sortDirection","indexOf","substring","sortRelProperty","localizedProperty"],"mappings":"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"}